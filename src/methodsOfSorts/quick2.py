#!/usr/bin/env python3
# -*- coding: utf-8 -*-

## 为什么有这个专题

自从CAT于去年改了考纲后，各位备考的pre - CATer们纷纷发现，过去编程题几乎就是送分题的时代一去不复返了。随之而来的是，题目越来越难了。以前只需掌握判断闰年等基本题型，编程便可轻松得分，从此不会再有。随之而来的是新名词、新题型。

“二分查找是什么鬼？”我想不少同学心里有这样的疑问。“这玩意儿，编程书没讲啊。”然后眼巴巴地看着本来可以到手的10分就这样溜走了。

不少考CAT的同学是第一次接触数据结构与算法，什么数据结构、x算法、y算法等对于pre-CATer来说都是新鲜事物、陌生名词。

那么，这个专栏的任务就是，让你对这些新名词不再陌生。

这个专栏会不定期更新，更新那些在考试中常见的算法，让你轻松将分得到。


## 思想

快速是一个基于“分而治之”思想的排序算法。“分治”的思想体现在：在数组中选定一个靶点（pivot），然后围绕这个靶点对数据进行分割（partition），比靶点小的分到左边，比靶点大的分到右边。然后递归实现，将所有数据都排好了。

上面这段话，想必初次读到的你，心里的想法一定是：“每个字我都认识，但连起来就不懂啥意思了。 ”

为了理解这段话本身，我们假定这样一个场景：你们班里10名男生站队。这10名男生有高个子也有矮个子，大家刚开始站的队也不是按身高站的。这时候老师挑了其中最帅的小A，站在最右边，并发号施令：“以小A为基准，个子比小A小的往左站，比小A大的往右站。”第一轮排序排好了，此时站在最右的是小B。然后老师再将发号施令：“以小B为基准，个子比小B小的往左站，比小B大的往右站。”如此循环往复，每次都以最右的同学为基准，最终的结果就是大家都按个子高低站好了。

那么，我们用一个数组来说明。

数组[2,1,5,3,8,4,9,5]，以最右边的5为基准。从最左的2开始遍历，一直遍历到最后一个5之前。建立两个辅助数组left和right，执行“不比5大的往左面，比5大的往右面”。一趟遍历过后，left数组中的数为[2, 1, 5, 3, 4]，right数组中的数为[8, 9]。

如果对递归掌握熟练，那么看到这里之后其实你的心中已有了答案：我只要对left数组和right数组递归执行同样的“以最右为基准，比最右小的往左，比最右大的往右”，这题就做完了。

那么我们可以写一个递归版本的代码如下：

```Python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def quick_sort(arr):
    if (not arr) or len(arr) == 1:
        # 如果arr是空数组或单元素数组，那么直接return它自身即可
        return arr

    # 选中基准点为最右一位
    pivot = arr[-1]
    # 建立空数组left和right
    left, right = list(), list()

    for elem in arr[:len(arr) - 1:]:
        # 像上面这样写可以保证不遍历到最后一位
        if elem <= pivot:
            left.append(elem)
        else:
            right.append(elem)

    return quick_sort(left) + [pivot] + quick_sort(right)
```

如果对递归掌握不熟练的话，我们可以用**迭代**的方式来实现。迭代，即使用循环的方式。在迭代的方式中，每次都用“最右”的同学作为基准，比最右高的靠右，比最右低的靠左。

那么我们的实现思路如下：
1. 建立一个辅助数组arr_aux，长度与arr相同，但元素全部为false；
2. 如有需要，封装一个swap()函数，用于两个位置交换数据；
3. 将arr_aux的最后一个元素标为true。称arr最后一个元素为pivot
4. 然后从头开始遍历数组arr。如果遇到arr[i] > pivot，那么交换两数位置。
5. 每遍历完一次数组后，检查arr_aux中是否所有元素为true。如是，则退出循环；如否，则循环继续，重复3-5步，直到满足退出循环的条件。

## 代码实现

```Python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def partition(ar, l, h):
    if h < l: # 以防输错。输错就交换一下
        h, l = l, h
    
    pivot = ar[h]
    i = l - 1
    
    for j in range(l, h):
        if ar[j] <= pivot:
            i += 1
            ar[i], ar[j] = ar[j], ar[i]
    
    ar[h], ar[i + 1] = ar[i + 1], ar[h]
    
    return i + 1

def quicksort(ar, l, h): # 执行快速排序的过程
    if l < h:
        pi = partition(ar, l, h)
        quicksort(ar, l, (pi - 1))
        quicksort(ar, (pi + 1), h)

if __name__ == "__main__":
    a = [1, 7, 2, 88, 3, 6, 12]
    len_ = len(a)
    quicksort(a, 0, (len(a) - 1))
    for i in range(len_):
        print("%d"%a[i])